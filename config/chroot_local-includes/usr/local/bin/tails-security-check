#! /usr/bin/perl

use strict;
use warnings FATAL => 'all';
use 5.10.1;

#man{{{

=head1 NAME

tails-security-check

=cut


=head1 DESCRIPTION

=head1 SYNOPSIS

tails-security-check [ ATOM_FEED_BASE_URL [ BUILD_DATE ] ]

  ATOM_FEED_BASE_URL will be appended /index.XX.atom,
  for XX in (current locale's language code, 'en'),
  until success is reported by the HTTP layer.

=head1 AUTHOR

Tails developers <tails@boum.org>
See https://tails.boum.org/.

=cut

#}}}

use Carp;
use Carp::Assert::More;
use DateTime;
use DateTime::Format::ISO8601;
use Desktop::Notify;
use Fatal qw{open close};
use Locale::gettext;
use POSIX;
use XML::Atom;
use XML::Atom::Feed;

### Initialization

use IO::Socket::SSL;
use Net::SSLeay;
BEGIN {
    IO::Socket::SSL::set_ctx_defaults(
        verify_mode => Net::SSLeay->VERIFY_PEER(),
        ca_file => '/etc/ssl/certs/UTN_USERFirst_Hardware_Root_CA.pem',
    );
}
use LWP::UserAgent; # needs to be *after* IO::Socket::SSL's initialization

setlocale(LC_MESSAGES, "");
textdomain("tails");

### configuration

my $version_file     = '/etc/amnesia/version';
my $default_base_url = 'https://tails.boum.org/security/';

### helper subs

=head2 build_date

Argument: file which the version information must be extracted from.

Returns a DateTime object that represents the build time extracted
from the version file.

=cut
sub build_date {
    my $version_file = shift;

    open my $version_h, '<', $version_file;
    my ($version, $date) = ( <$version_h> =~ /(.*) - (\d+)(?:\n)?$/ );
    close $version_h;
    assert_defined($date);
    assert_nonblank($date);

    return DateTime::Format::ISO8601->parse_datetime($date);
}

=head2 current_lang

Returns the two-letters language code of the current session.

=cut
sub current_lang {
    my ($code) = ($ENV{LANG} =~ m/([a-z]{2}).*/);

    return $code;
}

=head2 atom_str

Argument: an Atom feed URL

Returns the Atom's feed content on success, undef on failure.

=cut
sub atom_str {
    my $url = shift;
    assert_defined($url);

    $ENV{HTTPS_VERSION} = 3;

    my $ua  = LWP::UserAgent->new;
    $ua->proxy([qw(http https)] => 'socks://127.0.0.1:9062');
    my $req = HTTP::Request->new('GET', $url);
    my $res = $ua->request($req);
    if (defined $res && $res->is_success) {
        return $res->content;
    }

    return undef;
}

=head2 is_newer_than

Arguments: a XML::Atom::Entry, a DateTime object

Returns true if, and only if, the published field of the Atom entry is
newer than the time represented by the DateTime object.

=cut
sub is_newer_than {
    my $entry  = shift;
    my $ref_dt = shift;

    my $entry_published_dt = DateTime::Format::ISO8601->parse_datetime($entry->published);
    if (DateTime->compare($entry_published_dt, $ref_dt) == 1) {
        return 1;
    }
    return undef;
}

=head2 get_new_entries

Arguments: the Atom feed URL, a DateTime reference object.

Returns the list of XML::Atom::Entry's, taken from the feed, that have
been published after the reference time.

We use this poor man's manual Accept-Language algorithm as the website
layout does not allow us to use content negotiation.

=cut
sub get_new_entries {
    my $base_url = shift;
    my $since_dt = shift;
    assert_defined($base_url);
    assert_nonblank($base_url);
    assert_defined($since_dt);
    assert_isa($since_dt, 'DateTime');

    my $separator = '';
    $separator = '/' unless $base_url =~ m{/\z}xms;

    my @try_urls = (
        $base_url . $separator . 'index.' . current_lang() . '.atom',
        $base_url . $separator . 'index.en.atom',
    );

    my $feed_str;
    foreach my $url (@try_urls) {
        last if ($feed_str = atom_str($url));
    }
    assert_defined($feed_str);

    my $feed = XML::Atom::Feed->new(\$feed_str);
    return grep { is_newer_than($_, $since_dt) } $feed->entries();
}

=head2 notify_user

Use the Desktop Notifications framework to notify the user about the
Atom entries passed as arguments.

=cut
sub notify_user {
    my @entries = @_;

    my $notify = Desktop::Notify->new();

    my $summary = gettext('This version of Tails has known security issues:');
    my $body = '';

    map { $body = $body
              . '- '
              . '<a href="'
              . $_->id
              . '">'
              . $_->title
              . '</a>'
              . "\n";
      } @entries;

    $notify->create(summary => $summary,
                    body => $body,
                    timeout => 0)->show();
}

=head1 MAIN

=head2 sanity checks

=cut
if (! -e "$version_file") {
    die "The Tails version file ($version_file) does not exist."
}
if (! -r "$version_file") {
    die "The Tails version file ($version_file) is not readable."
}

=head2 parse command line args

=cut
my $base_url  = shift || $default_base_url;
my $opt_since = shift;
my $since_dt;
if (defined $opt_since) {
    $since_dt = DateTime::Format::ISO8601->parse_datetime($opt_since);
}
else {
    $since_dt = build_date($version_file);
}
assert_defined($since_dt);


=head2 do the work

=cut
my @newer_entries = get_new_entries($base_url, $since_dt);

if (! @newer_entries) {
    exit 0;
}
else {
    notify_user(@newer_entries);
}
