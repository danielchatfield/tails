In order to protect against memory recovery such as cold boot attack,
the system RAM is overwritten when Tails is being shutdown or when the
boot medium is physically removed.

#### The big picture

The previous implementation of the Tails memory erasure feature
suffered from flaws that were demonstrated by [[external
audit|security/audits/Blackhat_De-Anonymizing_Live_CDs]]. In short, it
only erased free memory and let data in the aufs read-write branch in
recoverable state.

In order to erase the biggest possible part of the system memory, the
hereby described new implementation, shipped in Tails 0.7, runs in a
fresh environment provided by a newly started Linux kernel. This way,
a given part of the memory either is *used* by the memory erasure
process itself or it is considered as free and thus *erased* by this
process; in any case, it is at least overwritten once.

#### initramfs tweaks

The Linux kernel and initramfs used to erase the memory are the same
as the ones normally used by a Tails system... that actually includes
some bits of code dedicated to this mission.

An initramfs-tools hook includes the necessary files in the initramfs
at build time. A runtime init-top script either does nothing, or
erases memory before shutting down or rebooting the system; its
behaviour depends on the `sdmem` kernel command line parameter value.

- [[!tails_gitweb config/chroot_local-includes/usr/share/initramfs-tools/hooks/hugetlb_mem_wipe]]
- [[!tails_gitweb config/chroot_local-includes/usr/share/initramfs-tools/scripts/init-top/hugetlb_mem_wipe]]

This `sdmem` is appended to the fresh kernel command
line parameters, when memory erasure is triggered, by the
`tails-kexec` initscript that is itself parameterized by the usual,
slightly customized, kexec-tools configuration file.

- [[!tails_gitweb config/chroot_local-includes/etc/default/kexec]]
- [[!tails_gitweb config/chroot_local-includes/etc/init.d/tails-kexec]]

#### Actual memory erasure process

The software that performs the actual memory erasure is a custom
program (`hugetlb_mem_wipe`) with the following design.

Memory wipe is done on memory areas allocated using `mmap()`. When the
memory is to be filled with zeros, it relies on the combination of
`MAP_ANONYMOUS | MAP_POPULATE | MAP_SHARED` flags which makes the kernel
clear the memory. Otherwise, it uses `memset()` on the allocated area.

First, pages are allocated using `MAP_HUGETLB`. Once all huge pages are
allocated, we continue the process using "usual" page size until we have
taken care of the amount of memory given on the command line.

A new process is spawned after one process has wiped 1 GB in order to
overcome the limit of maximum memory addressable by a single process
on 32-bit architectures.

Using huge pages should result in a faster wipe, as less page allocations are
required to clean up the whole memory. See
<http://linuxgazette.net/155/krishnakumar.html> for an introduction on huge
pages and hugetlb.

`hugetlb_mem_wipe` uses command-line arguments to know how much memory
still needs to be wiped, allowing to display a nice progress bar.

Overwriting the memory once with zeros is the fastest
available mode, and is enough to protect against every memory
forensics attack we know of.

The initramfs environment in which `hugetlb_mem_wipe` is run by
a script in a particular environment:

* Use `vm.overcommit_memory=2` and `vm.overcommit_ratio=100`: the
  C program works better when it gets a nice `ENOMEM` when requesting
  memory instead of being killed by the kernel.
* Set `vm.lowmem_reserve_ratio` to values that should not preserve
  much of the low memory areas (DMA, DMA32). This is the worst thing
  to do on a system with running drivers, but at this stage we should
  not have much loaded, and this allows to actually wipe more memory.
* Runs in init-top: there is no need to have udev working to perform
  the wipe.

The script also takes care of mounting the `hugetlbfs`
pseudo-filesystem that is needed to use `MAP_HUGETLB`, retrieves page
sizes (through `getconf` and `/proc/meminfo`) and passes them on the
`hugetlb_mem_wipe` command-line.

And finally, it computes the amount of memory that needs to be cleaned
by the C helper. It purposely substract the amount of memory in the
"cached" state. These bytes have already been overwritten by loading
files, so the previous content is already gone. This helps us to stay
away from the OOM-condition and reach the end of our nifty
progress bar.

- [[!tails_gitweb config/chroot_local-includes/etc/default/kexec]]
- [[!tails_gitweb config/chroot_local-includes/usr/src/hugetlb_mem_wipe.c]]
- [[!tails_gitweb config/chroot_local-hooks/52-hugetlb_mem_wipe]]

#### Triggers

Different kinds of events trigger the memory erasure process. All lead
to run the `tails-kexec` initscript.

**First, the memory erasure process is triggered at the end of a normal
shutdown/reboot sequence.** This is implemented by slightly modifying
the System V initscripts shipped by the `kexec-tools` Debian package:
the `kexec-load` initscript, that normally only runs at reboot time,
is enabled to run at shutdown time as well. A custom `tails-kexec`
initscript replaces the `kexec` one in order to support the case when
the boot medium is not available anymore at the time this script runs;
it also provides an improved user interface more suitable for Tails
target users needs. Finally, the standard Debian `halt` and `reboot`
initscripts are disabled as 

- [[!tails_gitweb config/chroot_local-patches/run_kexec-load_on_halt.diff]]
- [[!tails_gitweb config/chroot_local-includes/etc/init.d/tails-kexec]]
- [[!tails_gitweb config/chroot_local-hooks/52-update-rc.d]]

**Second, the memory erasure process is triggered when the boot medium
is physically removed during runtime (USB boot medium is unplugged or
boot CD is ejected).** This is implemented by a custom `udev-watchdog`
program monitors the boot medium; it's run by a wrapper, started at
boot time, that brutally invokes the memory erasure process, bypassing
other system shutdown scripts, when this medium happens to be
physically removed.

- [[!tails_gitweb config/chroot_local-includes/usr/local/sbin/udev-watchdog-wrapper]]
- [[!tails_gitweb config/chroot_local-includes/usr/src/udev-watchdog.c]]
- [[!tails_gitweb config/chroot_local-hooks/52-udev-watchdog]]
- [[!tails_gitweb config/chroot_local-includes/etc/init.d/tails-sdmem-on-media-removal]]
- [[!tails_gitweb config/chroot_local-hooks/52-update-rc.d]]

#### Making sure needed files are available

The memlockd daemon, appropriately configured, ensures every file
needed by the memory erasure process is locked into memory from boot
to memory erasure time.

- [[!debpts memlockd]]
- [[!tails_gitweb config/chroot_local-includes/etc/memlockd.cfg]]

#### User interface

Since this process can take a while the user can leave the computer
and let it finish on its own after removing the boot medium, or simply
turn it off if he or she is not worried about this attack: if Tails
was booted from a CD it is ejected before the memory wiping is
started, and if it was booted from a USB drive it can be removed as
soon as the memory wiping has been started.

A short but visible message, displayed for a few seconds, explains the
user what is going to happen.

- [[!tails_gitweb config/chroot_local-includes/etc/init.d/tails-kexec]]
